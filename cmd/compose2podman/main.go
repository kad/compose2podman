// Package main provides the compose2podman CLI tool for converting Docker Compose files
// to Podman-compatible formats (Kubernetes YAML and Quadlet files).
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"github.com/kad/compose2podman/internal/types"
	"github.com/kad/compose2podman/pkg/kube"
	"github.com/kad/compose2podman/pkg/parser"
	"github.com/kad/compose2podman/pkg/quadlet"
)

var (
	version = "dev"
	commit  = "none"
	date    = "unknown"
	builtBy = "unknown"
)

func main() {
	var (
		inputFile   string
		outputType  string
		outputPath  string
		podName     string
		showVersion bool
		noWarning   bool
	)

	// Define flags with both long and short variants
	flag.StringVar(&inputFile, "input", "", "Path to docker-compose file")
	flag.StringVar(&inputFile, "i", "", "Path to docker-compose file (shorthand)")
	flag.StringVar(&outputType, "type", "kube", "Output type: kube or quadlet")
	flag.StringVar(&outputType, "t", "kube", "Output type: kube or quadlet (shorthand)")
	flag.StringVar(&outputPath, "output", "", "Output file (for kube) or directory (for quadlet)")
	flag.StringVar(&outputPath, "o", "", "Output file (for kube) or directory (for quadlet) (shorthand)")
	flag.StringVar(&podName, "pod-name", "compose-pod", "Pod name for Kubernetes output")
	flag.StringVar(&podName, "p", "compose-pod", "Pod name for Kubernetes output (shorthand)")
	flag.BoolVar(&showVersion, "version", false, "Show version information")
	flag.BoolVar(&showVersion, "V", false, "Show version information (shorthand)")
	flag.BoolVar(&noWarning, "no-warning", false, "Suppress proof-of-concept warning")
	flag.BoolVar(&noWarning, "q", false, "Suppress proof-of-concept warning (shorthand)")

	flag.Parse()

	if showVersion {
		fmt.Printf("compose2podman version %s\n", version)
		if commit != "none" {
			fmt.Printf("  commit: %s\n", commit)
		}
		if date != "unknown" {
			fmt.Printf("  built at: %s\n", date)
		}
		if builtBy != "unknown" {
			fmt.Printf("  built by: %s\n", builtBy)
		}
		fmt.Println("\n⚠️  PROOF-OF-CONCEPT: Not tested with real data. Not for production use.")
		os.Exit(0)
	}

	// Show warning unless suppressed
	if !noWarning {
		fmt.Fprintln(os.Stderr, "⚠️  WARNING: This is a PROOF-OF-CONCEPT tool generated by GitHub Copilot.")
		fmt.Fprintln(os.Stderr, "   NOT tested with real data. NOT intended for production use.")
		fmt.Fprintln(os.Stderr, "   Always verify generated output before use.")
		fmt.Fprintln(os.Stderr, "   Use -no-warning or -q to suppress this message.")
	}

	// If no input file specified, look for standard docker-compose file names
	if inputFile == "" {
		inputFile = findComposeFile()
	}

	// Parse compose file
	compose, err := parser.ParseComposeFile(inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing compose file: %v\n", err)
		os.Exit(1)
	}

	switch outputType {
	case "kube", "kubernetes":
		if err := generateKube(compose, outputPath, podName); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Kubernetes YAML: %v\n", err)
			os.Exit(1)
		}
	case "quadlet":
		if err := generateQuadlet(compose, outputPath); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Quadlet files: %v\n", err)
			os.Exit(1)
		}
	default:
		fmt.Fprintf(os.Stderr, "Unknown output type: %s (use 'kube' or 'quadlet')\n", outputType)
		os.Exit(1)
	}
}

// findComposeFile looks for standard docker-compose file names in the current directory
// Following the same order as docker-compose: compose.yaml, compose.yml, docker-compose.yaml, docker-compose.yml
func findComposeFile() string {
	// Standard file names docker-compose looks for, in order of preference
	candidates := []string{
		"compose.yaml",
		"compose.yml",
		"docker-compose.yaml",
		"docker-compose.yml",
	}

	for _, name := range candidates {
		if _, err := os.Stat(name); err == nil {
			return name
		}
	}

	// If none found, return the default (will error later with helpful message)
	return "docker-compose.yaml"
}

func generateKube(compose *types.ComposeFile, outputPath, podName string) error {
	gen := kube.NewGenerator(compose, podName)
	yaml, err := gen.Generate()
	if err != nil {
		return err
	}

	if outputPath == "" {
		outputPath = "pod.yaml"
	}

	// Write output file with readable permissions (0644 is intentional for output files)
	//nolint:gosec // G306: Output files should be readable by others
	if err := os.WriteFile(outputPath, []byte(yaml), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	fmt.Printf("✓ Generated Kubernetes Pod YAML: %s\n", outputPath)
	fmt.Printf("  Use with: podman play kube %s\n", outputPath)
	return nil
}

func generateQuadlet(compose *types.ComposeFile, outputPath string) error {
	if outputPath == "" {
		outputPath = "quadlet-output"
	}

	gen := quadlet.NewGenerator(compose, outputPath)
	if err := gen.Generate(); err != nil {
		return err
	}

	fmt.Printf("✓ Generated Quadlet files in: %s\n", outputPath)
	fmt.Printf("  Copy files to: ~/.config/containers/systemd/ or /etc/containers/systemd/\n")
	fmt.Printf("  Then run: systemctl --user daemon-reload\n")

	// List generated files
	entries, err := os.ReadDir(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading output directory: %v\n", err)
		os.Exit(1)
	}
	if len(entries) > 0 {
		fmt.Printf("  Generated files:\n")
		for _, entry := range entries {
			ext := filepath.Ext(entry.Name())
			fmt.Printf("    - %s (%s)\n", entry.Name(), ext)
		}
	}

	return nil
}
