// Package main provides the compose2podman CLI tool for converting Docker Compose files
// to Podman-compatible formats (Kubernetes YAML and Quadlet files).
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"github.com/kad/compose2podman/internal/types"
	"github.com/kad/compose2podman/pkg/kube"
	"github.com/kad/compose2podman/pkg/parser"
	"github.com/kad/compose2podman/pkg/quadlet"
)

var (
	version = "dev"
	commit  = "none"
	date    = "unknown"
	builtBy = "unknown"
)

func main() {
	var (
		inputFile   = flag.String("input", "docker-compose.yaml", "Path to docker-compose.yaml file")
		outputType  = flag.String("type", "kube", "Output type: kube or quadlet")
		outputPath  = flag.String("output", "", "Output file (for kube) or directory (for quadlet)")
		podName     = flag.String("pod-name", "compose-pod", "Pod name for Kubernetes output")
		showVersion = flag.Bool("version", false, "Show version information")
		noWarning   = flag.Bool("no-warning", false, "Suppress proof-of-concept warning")
	)

	flag.Parse()

	if *showVersion {
		fmt.Printf("compose2podman version %s\n", version)
		if commit != "none" {
			fmt.Printf("  commit: %s\n", commit)
		}
		if date != "unknown" {
			fmt.Printf("  built at: %s\n", date)
		}
		if builtBy != "unknown" {
			fmt.Printf("  built by: %s\n", builtBy)
		}
		fmt.Println("\n⚠️  PROOF-OF-CONCEPT: Not tested with real data. Not for production use.")
		os.Exit(0)
	}

	// Show warning unless suppressed
	if !*noWarning {
		fmt.Fprintln(os.Stderr, "⚠️  WARNING: This is a PROOF-OF-CONCEPT tool generated by GitHub Copilot.")
		fmt.Fprintln(os.Stderr, "   NOT tested with real data. NOT intended for production use.")
		fmt.Fprintln(os.Stderr, "   Always verify generated output before use.")
		fmt.Fprintln(os.Stderr, "   Use -no-warning to suppress this message.")
	}

	// Parse compose file
	compose, err := parser.ParseComposeFile(*inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing compose file: %v\n", err)
		os.Exit(1)
	}

	switch *outputType {
	case "kube", "kubernetes":
		if err := generateKube(compose, *outputPath, *podName); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Kubernetes YAML: %v\n", err)
			os.Exit(1)
		}
	case "quadlet":
		if err := generateQuadlet(compose, *outputPath); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Quadlet files: %v\n", err)
			os.Exit(1)
		}
	default:
		fmt.Fprintf(os.Stderr, "Unknown output type: %s (use 'kube' or 'quadlet')\n", *outputType)
		os.Exit(1)
	}
}

func generateKube(compose *types.ComposeFile, outputPath, podName string) error {
	gen := kube.NewGenerator(compose, podName)
	yaml, err := gen.Generate()
	if err != nil {
		return err
	}

	if outputPath == "" {
		outputPath = "pod.yaml"
	}

	// Write output file with readable permissions (0644 is intentional for output files)
	//nolint:gosec // G306: Output files should be readable by others
	if err := os.WriteFile(outputPath, []byte(yaml), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	fmt.Printf("✓ Generated Kubernetes Pod YAML: %s\n", outputPath)
	fmt.Printf("  Use with: podman play kube %s\n", outputPath)
	return nil
}

func generateQuadlet(compose *types.ComposeFile, outputPath string) error {
	if outputPath == "" {
		outputPath = "quadlet-output"
	}

	gen := quadlet.NewGenerator(compose, outputPath)
	if err := gen.Generate(); err != nil {
		return err
	}

	fmt.Printf("✓ Generated Quadlet files in: %s\n", outputPath)
	fmt.Printf("  Copy files to: ~/.config/containers/systemd/ or /etc/containers/systemd/\n")
	fmt.Printf("  Then run: systemctl --user daemon-reload\n")

	// List generated files
	entries, err := os.ReadDir(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading output directory: %v\n", err)
		os.Exit(1)
	}
	if len(entries) > 0 {
		fmt.Printf("  Generated files:\n")
		for _, entry := range entries {
			ext := filepath.Ext(entry.Name())
			fmt.Printf("    - %s (%s)\n", entry.Name(), ext)
		}
	}

	return nil
}
