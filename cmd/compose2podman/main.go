// Package main provides the compose2podman CLI tool for converting Docker Compose files
// to Podman-compatible formats (Kubernetes YAML and Quadlet files).
package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"

	"github.com/kad/compose2podman/internal/types"
	"github.com/kad/compose2podman/pkg/kube"
	"github.com/kad/compose2podman/pkg/parser"
	"github.com/kad/compose2podman/pkg/quadlet"
)

var (
	version = "dev"
	commit  = "none"
	date    = "unknown"
	builtBy = "unknown"
)

var (
	inputFile  string
	outputType string
	outputPath string
	podName    string
	noWarning  bool
)

func main() {
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

var rootCmd = &cobra.Command{
	Use:   "compose2podman",
	Short: "Convert Docker Compose files to Podman formats",
	Long: `compose2podman converts Docker Compose files to Podman-compatible formats.

Supports two output formats:
  - Kubernetes YAML for 'podman play kube'
  - Podman Quadlet files for systemd integration

⚠️  WARNING: This is a PROOF-OF-CONCEPT tool generated by GitHub Copilot.
   NOT tested with real data. NOT intended for production use.
   Always verify generated output before use.`,
	Version: version,
	RunE:    run,
	SilenceUsage: true,
}

func init() {
	rootCmd.PersistentFlags().StringVarP(&inputFile, "input", "i", "", "Path to docker-compose file (auto-detects if not specified)")
	rootCmd.PersistentFlags().StringVarP(&outputType, "type", "t", "kube", "Output type: kube or quadlet")
	rootCmd.PersistentFlags().StringVarP(&outputPath, "output", "o", "", "Output file (kube) or directory (quadlet)")
	rootCmd.PersistentFlags().StringVarP(&podName, "pod-name", "p", "compose-pod", "Pod name for Kubernetes output")
	rootCmd.PersistentFlags().BoolVarP(&noWarning, "quiet", "q", false, "Suppress proof-of-concept warning")

	// Custom version template
	rootCmd.SetVersionTemplate(`compose2podman version {{.Version}}
{{if ne .Version "dev"}}  commit: ` + commit + `
  built at: ` + date + `
  built by: ` + builtBy + `{{end}}

⚠️  PROOF-OF-CONCEPT: Not tested with real data. Not for production use.
`)
}

func run(cmd *cobra.Command, args []string) error {
	// Show warning unless suppressed
	if !noWarning {
		fmt.Fprintln(os.Stderr, "⚠️  WARNING: This is a PROOF-OF-CONCEPT tool generated by GitHub Copilot.")
		fmt.Fprintln(os.Stderr, "   NOT tested with real data. NOT intended for production use.")
		fmt.Fprintln(os.Stderr, "   Always verify generated output before use.")
		fmt.Fprintln(os.Stderr, "   Use --quiet or -q to suppress this message.")
	}

	// If no input file specified, look for standard docker-compose file names
	if inputFile == "" {
		inputFile = findComposeFile()
	}

	// Parse compose file
	compose, err := parser.ParseComposeFile(inputFile)
	if err != nil {
		return fmt.Errorf("error parsing compose file: %w", err)
	}

	switch outputType {
	case "kube", "kubernetes":
		return generateKube(compose, outputPath, podName)
	case "quadlet":
		return generateQuadlet(compose, outputPath)
	default:
		return fmt.Errorf("unknown output type: %s (use 'kube' or 'quadlet')", outputType)
	}
}

// findComposeFile looks for standard docker-compose file names in the current directory
// Following the same order as docker-compose: compose.yaml, compose.yml, docker-compose.yaml, docker-compose.yml
func findComposeFile() string {
	// Standard file names docker-compose looks for, in order of preference
	candidates := []string{
		"compose.yaml",
		"compose.yml",
		"docker-compose.yaml",
		"docker-compose.yml",
	}

	for _, name := range candidates {
		if _, err := os.Stat(name); err == nil {
			return name
		}
	}

	// If none found, return the default (will error later with helpful message)
	return "docker-compose.yaml"
}

func generateKube(compose *types.ComposeFile, outputPath, podName string) error {
	gen := kube.NewGenerator(compose, podName)
	yaml, err := gen.Generate()
	if err != nil {
		return err
	}

	if outputPath == "" {
		outputPath = "pod.yaml"
	}

	// Write output file with readable permissions (0644 is intentional for output files)
	//nolint:gosec // G306: Output files should be readable by others
	if err := os.WriteFile(outputPath, []byte(yaml), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	fmt.Printf("✓ Generated Kubernetes Pod YAML: %s\n", outputPath)
	fmt.Printf("  Use with: podman play kube %s\n", outputPath)
	return nil
}

func generateQuadlet(compose *types.ComposeFile, outputPath string) error {
	if outputPath == "" {
		outputPath = "quadlet-output"
	}

	gen := quadlet.NewGenerator(compose, outputPath)
	if err := gen.Generate(); err != nil {
		return err
	}

	fmt.Printf("✓ Generated Quadlet files in: %s\n", outputPath)
	fmt.Printf("  Copy files to: ~/.config/containers/systemd/ or /etc/containers/systemd/\n")
	fmt.Printf("  Then run: systemctl --user daemon-reload\n")

	// List generated files
	entries, err := os.ReadDir(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading output directory: %v\n", err)
		os.Exit(1)
	}
	if len(entries) > 0 {
		fmt.Printf("  Generated files:\n")
		for _, entry := range entries {
			ext := filepath.Ext(entry.Name())
			fmt.Printf("    - %s (%s)\n", entry.Name(), ext)
		}
	}

	return nil
}
